{"code":"import path from 'path';\r\nimport EventEmitter from 'events';\r\nimport chalk from 'chalk';\r\nimport minimost from 'minimost';\r\nimport readPkg from 'read-pkg-up';\r\nimport Command from './Command';\r\nimport Options from './Options';\r\nimport Help from './Help';\r\nimport examplesPlugin from './plugins/command-examples';\r\nimport optionChoicesPlugin from './plugins/option-choices';\r\nimport requiredOptionPlugin from './plugins/required-option';\r\nimport { textTable, isExplictCommand } from './utils';\r\n// Prevent caching of this module so module.parent is always accurate\r\ndelete require.cache[__filename];\r\nconst parentDir = path.dirname(module.parent.filename);\r\nexport default class Cac extends EventEmitter {\r\n    constructor({ bin, pkg, defaultOpts = true } = {}) {\r\n        super();\r\n        this.bin = bin || path.basename(process.argv[1]);\r\n        this.commands = [];\r\n        this.options = new Options();\r\n        this.extraHelps = [];\r\n        this.helpOpt = defaultOpts !== false && defaultOpts.help !== false;\r\n        this.versionOpt = defaultOpts !== false && defaultOpts.version !== false;\r\n        this.pkg = Object.assign({}, pkg || readPkg.sync({ cwd: parentDir, normalize: false }).pkg);\r\n        if (this.versionOpt) {\r\n            this.option('version', {\r\n                alias: 'v',\r\n                type: 'boolean',\r\n                desc: 'Display version'\r\n            });\r\n        }\r\n        if (this.helpOpt) {\r\n            this.option('help', {\r\n                alias: 'h',\r\n                type: 'boolean',\r\n                desc: `Display help (You're already here)`\r\n            });\r\n        }\r\n        this.use(examplesPlugin());\r\n        this.use(optionChoicesPlugin());\r\n        this.use(requiredOptionPlugin());\r\n    }\r\n    use(plugin) {\r\n        if (Array.isArray(plugin)) {\r\n            plugin.forEach(p => this.use(p));\r\n        }\r\n        else if (typeof plugin === 'function') {\r\n            plugin(this);\r\n        }\r\n        else {\r\n            throw new TypeError('plugin has to be a function or an array of it.');\r\n        }\r\n        return this;\r\n    }\r\n    option(...args) {\r\n        this.options.add(...args);\r\n        return this;\r\n    }\r\n    command(...args) {\r\n        const command = new Command(...args);\r\n        this.commands.push(command);\r\n        return command;\r\n    }\r\n    commandsToString() {\r\n        return textTable(this.commands.map(({ command }) => {\r\n            return [\r\n                command.names.map(v => chalk.magenta(v)).join(', '),\r\n                chalk.dim(command.desc)\r\n            ];\r\n        }));\r\n    }\r\n    isCommandsEmpty() {\r\n        return this.commands.length === 0;\r\n    }\r\n    /**\r\n     * Find command by command name, alias or addtionalMatch\r\n     */\r\n    findCommand(name) {\r\n        for (const command of this.commands) {\r\n            const { names, match } = command.command;\r\n            if (names.includes(name)) {\r\n                return { command, sliceFirstArg: name && name !== '*' };\r\n            }\r\n            if (match && match(name)) {\r\n                return { command, sliceFirstArg: false };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getCommand(name) {\r\n        return this.findCommand(name) || this.findCommand('*') || {};\r\n    }\r\n    get argv() {\r\n        return this.parse(null, { run: false });\r\n    }\r\n    showHelp() {\r\n        if (!this.started) {\r\n            throw new Error('[cac] You have to call .parse() before running .showHelp()');\r\n        }\r\n        // Do not display `<command>` in help if it's a sub command\r\n        const displayCommands = !(this.matchedCommand && isExplictCommand(this.firstArg));\r\n        const help = new Help(this, this.matchedCommand, {\r\n            displayCommands\r\n        });\r\n        help.output();\r\n        return this;\r\n    }\r\n    showVersion() {\r\n        console.log(this.pkg.version);\r\n    }\r\n    extraHelp(help) {\r\n        this.extraHelps.push(help);\r\n        return this;\r\n    }\r\n    parse(argv, { run = true, showHelp } = {}) {\r\n        this.started = true;\r\n        argv = argv || process.argv.slice(2);\r\n        this.firstArg = argv[0] || '';\r\n        // Ensure that first arg is not a flag\r\n        this.firstArg = this.firstArg.startsWith('-') ? null : this.firstArg;\r\n        const { command, sliceFirstArg } = this.getCommand(this.firstArg);\r\n        this.matchedCommand = command;\r\n        let { input, flags } = minimost(argv, {\r\n            boolean: [\r\n                ...this.options.getOptionNamesByType('boolean'),\r\n                ...(command ? command.options.getOptionNamesByType('boolean') : [])\r\n            ],\r\n            string: [\r\n                ...this.options.getOptionNamesByType('string'),\r\n                ...(command ? command.options.getOptionNamesByType('string') : [])\r\n            ],\r\n            default: Object.assign({}, this.options.getDefaultsMapping(), (command ? command.options.getDefaultsMapping() : [])),\r\n            alias: Object.assign({}, this.options.getAliasMap(), (command ? command.options.getAliasMap() : {}))\r\n        });\r\n        input = sliceFirstArg ? input.slice(1) : input;\r\n        this.emit('parsed', command, input, flags);\r\n        if (!run) {\r\n            return { input, flags };\r\n        }\r\n        const shouldShowHelp = showHelp || ((command, input, flags) => this.helpOpt && flags.help);\r\n        if (shouldShowHelp(command, input, flags)) {\r\n            this.showHelp();\r\n        }\r\n        else if (this.versionOpt && flags.version) {\r\n            this.showVersion();\r\n        }\r\n        else if (command && command.handler) {\r\n            try {\r\n                let res = command.handler(input, flags);\r\n                if (res && res.catch) {\r\n                    res = res.catch(err => this.handleError(err));\r\n                }\r\n                this.emit('executed', command, input, flags);\r\n                return res;\r\n            }\r\n            catch (err) {\r\n                this.handleError(err);\r\n            }\r\n        }\r\n    }\r\n    handleError(err) {\r\n        if (EventEmitter.listenerCount(this, 'error') === 0) {\r\n            console.error(err.stack);\r\n            process.exitCode = process.exitCode || 1;\r\n        }\r\n        else {\r\n            this.emit('error', err);\r\n        }\r\n    }\r\n}\r\n","dts":{"name":"/Users/egoist/dev/cac/Cac.d.ts","text":"/// <reference types=\"node\" />\r\nimport EventEmitter from 'events';\r\nimport Command from './Command';\r\nexport interface IOptions {\r\n    bin?: string;\r\n    pkg?: {\r\n        [k: string]: any;\r\n    };\r\n    defaultOpts?: boolean;\r\n}\r\nexport default class Cac extends EventEmitter {\r\n    bin: string;\r\n    pkg: {\r\n        [k: string]: any;\r\n    };\r\n    extraHelps: string[];\r\n    helpOpt: boolean;\r\n    versionOpt: boolean;\r\n    constructor({bin, pkg, defaultOpts}?: IOptions);\r\n    use(plugin: any): this;\r\n    option(...args: any[]): this;\r\n    command(...args: any[]): Command;\r\n    commandsToString(): string;\r\n    isCommandsEmpty(): boolean;\r\n    /**\r\n     * Find command by command name, alias or addtionalMatch\r\n     */\r\n    findCommand(name: any): {\r\n        command: any;\r\n        sliceFirstArg: boolean;\r\n    } | null;\r\n    getCommand(name: any): {};\r\n    readonly argv: any;\r\n    showHelp(): this;\r\n    showVersion(): void;\r\n    extraHelp(help: any): this;\r\n    parse(argv: any, {run, showHelp}?: {\r\n        run?: boolean;\r\n        showHelp: any;\r\n    }): any;\r\n    handleError(err: any): void;\r\n}\r\n"}}
